/* Generated By:JavaCC: Do not edit this line. BPP.java */
package medit.BPP;

import medit.BPP.syntaxtree.AdditiveExpression;
import medit.BPP.syntaxtree.IfExpression;
import medit.BPP.syntaxtree.JavaStaticMethods;
import medit.BPP.syntaxtree.MathExpression;
import medit.BPP.syntaxtree.MultiplicativeExpression;
import medit.BPP.syntaxtree.NodeChoice;
import medit.BPP.syntaxtree.NodeList;
import medit.BPP.syntaxtree.NodeListOptional;
import medit.BPP.syntaxtree.NodeOptional;
import medit.BPP.syntaxtree.NodeSequence;
import medit.BPP.syntaxtree.NodeToken;
import medit.BPP.syntaxtree.RelationalEqualityExpression;
import medit.BPP.syntaxtree.RelationalExprssion;
import medit.BPP.syntaxtree.RelationalGreaterExpression;
import medit.BPP.syntaxtree.RelationalLessExpression;
import medit.BPP.syntaxtree.Require;
import medit.BPP.syntaxtree.Start;
import medit.BPP.syntaxtree.StatementExpression;
import medit.BPP.syntaxtree.UnaryExpression;
import medit.BPP.syntaxtree.UnaryRelational;
import medit.BPP.syntaxtree.VariableAssign;
import medit.BPP.syntaxtree.VariableDeclaration;
import medit.BPP.syntaxtree.VariableName;
import medit.BPP.syntaxtree.WhileExpression;

public class BPP implements BPPConstants {

	static final class JJCalls {
		int arg;
		Token first;
		int gen;
		JJCalls next;
	}

	static private final class LookaheadSuccess extends java.lang.Error {

		/**
		 *
		 */
		private static final long serialVersionUID = 1L;
	}

	static private int[] jj_la1_0;

	static private int[] jj_la1_1;

	static {
		BPP.jj_la1_init_0();
		BPP.jj_la1_init_1();
	}

	private static void jj_la1_init_0() {
		BPP.jj_la1_0 = new int[] { 0x40, 0x8000980, 0x8000000, 0x300000, 0x300000, 0x1c00000, 0x1c00000, 0x4c000000,
				0x84000, 0x84000, 0x28000, 0x28000, 0x50000, 0x50000, 0x8000980, 0x8000980, 0x2000, 0x0, 0x800,
				0x8000180, };
	}

	private static void jj_la1_init_1() {
		BPP.jj_la1_1 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x1, 0x0, 0x0, };
	}

	final private JJCalls[] jj_2_rtns = new JJCalls[1];

	private int jj_endpos;

	private final java.util.List<int[]> jj_expentries = new java.util.ArrayList<>();

	private int[] jj_expentry;

	private int jj_gc = 0;

	private int jj_gen;

	SimpleCharStream jj_input_stream;

	private int jj_kind = -1;

	private int jj_la;

	final private int[] jj_la1 = new int[20];

	private final int[] jj_lasttokens = new int[100];

	final private LookaheadSuccess jj_ls = new LookaheadSuccess();

	/** Next token. */
	public Token jj_nt;

	private int jj_ntk;

	private boolean jj_rescan = false;

	private Token jj_scanpos, jj_lastpos;
	/** Current token. */
	public Token token;
	/** Generated Token Manager. */
	public BPPTokenManager token_source;

	/** Constructor with generated Token Manager. */
	public BPP(final BPPTokenManager tm) {
		this.token_source = tm;
		this.token = new Token();
		this.jj_ntk = -1;
		this.jj_gen = 0;
		for (int i = 0; i < 20; i++)
			this.jj_la1[i] = -1;
		for (int i = 0; i < this.jj_2_rtns.length; i++)
			this.jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor with InputStream. */
	public BPP(final java.io.InputStream stream) {
		this(stream, null);
	}

	/** Constructor with InputStream and supplied encoding */
	public BPP(final java.io.InputStream stream, final String encoding) {
		try {
			this.jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		} catch (final java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		this.token_source = new BPPTokenManager(this.jj_input_stream);
		this.token = new Token();
		this.jj_ntk = -1;
		this.jj_gen = 0;
		for (int i = 0; i < 20; i++)
			this.jj_la1[i] = -1;
		for (int i = 0; i < this.jj_2_rtns.length; i++)
			this.jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor. */
	public BPP(final java.io.Reader stream) {
		this.jj_input_stream = new SimpleCharStream(stream, 1, 1);
		this.token_source = new BPPTokenManager(this.jj_input_stream);
		this.token = new Token();
		this.jj_ntk = -1;
		this.jj_gen = 0;
		for (int i = 0; i < 20; i++)
			this.jj_la1[i] = -1;
		for (int i = 0; i < this.jj_2_rtns.length; i++)
			this.jj_2_rtns[i] = new JJCalls();
	}

	final public AdditiveExpression AdditiveExpression() throws ParseException {
		// --- JTB generated node declarations ---
		MultiplicativeExpression n0 = null;
		final NodeListOptional n1 = new NodeListOptional();
		NodeSequence n2 = null;
		NodeChoice n3 = null;
		NodeToken n4 = null;
		final Token n5 = null;
		NodeToken n6 = null;
		final Token n7 = null;
		MultiplicativeExpression n8 = null;
		n0 = this.MultiplicativeExpression();
		label_4: while (true) {
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case PLUS:
			case MINUS:
				;
				break;
			default:
				this.jj_la1[3] = this.jj_gen;
				break label_4;
			}
			n2 = new NodeSequence(2);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case PLUS:
				this.jj_consume_token(BPPConstants.PLUS);
				n4 = JTBToolkit.makeNodeToken(n5);
				n3 = new NodeChoice(n4, 0, 2);
				break;
			case MINUS:
				this.jj_consume_token(BPPConstants.MINUS);
				n6 = JTBToolkit.makeNodeToken(n7);
				n3 = new NodeChoice(n6, 1, 2);
				break;
			default:
				this.jj_la1[4] = this.jj_gen;
				this.jj_consume_token(-1);
				throw new ParseException();
			}
			n2.addNode(n3);
			n8 = this.MultiplicativeExpression();
			n2.addNode(n8);
			n1.addNode(n2);
		}
		n1.nodes.trimToSize();
		{
			if (true)
				return new AdditiveExpression(n0, n1);
		}
		throw new Error("Missing return statement in function");
	}

	/** Disable tracing. */
	final public void disable_tracing() {
	}

	/** Enable tracing. */
	final public void enable_tracing() {
	}

	/** Generate ParseException. */
	public ParseException generateParseException() {
		this.jj_expentries.clear();
		final boolean[] la1tokens = new boolean[33];
		if (this.jj_kind >= 0) {
			la1tokens[this.jj_kind] = true;
			this.jj_kind = -1;
		}
		for (int i = 0; i < 20; i++)
			if (this.jj_la1[i] == this.jj_gen)
				for (int j = 0; j < 32; j++) {
					if ((BPP.jj_la1_0[i] & 1 << j) != 0)
						la1tokens[j] = true;
					if ((BPP.jj_la1_1[i] & 1 << j) != 0)
						la1tokens[32 + j] = true;
				}
		for (int i = 0; i < 33; i++)
			if (la1tokens[i]) {
				this.jj_expentry = new int[1];
				this.jj_expentry[0] = i;
				this.jj_expentries.add(this.jj_expentry);
			}
		this.jj_endpos = 0;
		this.jj_rescan_token();
		this.jj_add_error_token(0, 0);
		final int[][] exptokseq = new int[this.jj_expentries.size()][];
		for (int i = 0; i < this.jj_expentries.size(); i++)
			exptokseq[i] = this.jj_expentries.get(i);
		return new ParseException(this.token, exptokseq, BPPConstants.tokenImage);
	}

	/** Get the next Token. */
	final public Token getNextToken() {
		if (this.token.next != null)
			this.token = this.token.next;
		else
			this.token = this.token.next = this.token_source.getNextToken();
		this.jj_ntk = -1;
		this.jj_gen++;
		return this.token;
	}

	/** Get the specific Token. */
	final public Token getToken(final int index) {
		Token t = this.token;
		for (int i = 0; i < index; i++)
			if (t.next != null)
				t = t.next;
			else
				t = t.next = this.token_source.getNextToken();
		return t;
	}

	/* End Simple Relational Test */
	/*
	 * "if" expression is a classcal test if true do something like in :
	 * ----------------------------------------------- Java | VB
	 * ----------------------------------------------- if( 1 > 0 ) | If 1 > 0 Then {
	 * | ... ... | End If } | | Here is : if 1 > 0 do ... stop
	 *
	 * "stop" is end of if block
	 */
	final public IfExpression IfExpression() throws ParseException {
		// --- JTB generated node declarations ---
		NodeToken n0 = null;
		final Token n1 = null;
		RelationalExprssion n2 = null;
		NodeToken n3 = null;
		final Token n4 = null;
		final NodeListOptional n5 = new NodeListOptional();
		StatementExpression n6 = null;
		NodeToken n7 = null;
		final Token n8 = null;
		this.jj_consume_token(BPPConstants.IF);
		n0 = JTBToolkit.makeNodeToken(n1);
		n2 = this.RelationalExprssion();
		this.jj_consume_token(BPPConstants.DO);
		n3 = JTBToolkit.makeNodeToken(n4);
		label_6: while (true) {
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case IF:
			case WHILE:
			case DEF:
			case IDENTIFIER:
				;
				break;
			default:
				this.jj_la1[14] = this.jj_gen;
				break label_6;
			}
			n6 = this.StatementExpression();
			n5.addNode(n6);
		}
		n5.nodes.trimToSize();
		this.jj_consume_token(BPPConstants.STOP);
		n7 = JTBToolkit.makeNodeToken(n8);
		{
			if (true)
				return new IfExpression(n0, n2, n3, n5, n7);
		}
		throw new Error("Missing return statement in function");
	}

	final public JavaStaticMethods JavaStaticMethods() throws ParseException {
		// --- JTB generated node declarations ---
		NodeToken n0 = null;
		final Token n1 = null;
		final NodeList n2 = new NodeList();
		NodeSequence n3 = null;
		NodeToken n4 = null;
		final Token n5 = null;
		NodeToken n6 = null;
		final Token n7 = null;
		NodeToken n8 = null;
		final Token n9 = null;
		MathExpression n10 = null;
		final NodeListOptional n11 = new NodeListOptional();
		NodeSequence n12 = null;
		NodeToken n13 = null;
		final Token n14 = null;
		MathExpression n15 = null;
		NodeToken n16 = null;
		final Token n17 = null;
		NodeToken n18 = null;
		final Token n19 = null;
		this.jj_consume_token(BPPConstants.IDENTIFIER);
		n0 = JTBToolkit.makeNodeToken(n1);
		label_8: while (true) {
			n3 = new NodeSequence(2);
			this.jj_consume_token(BPPConstants.COLON);
			n4 = JTBToolkit.makeNodeToken(n5);
			n3.addNode(n4);
			this.jj_consume_token(BPPConstants.IDENTIFIER);
			n6 = JTBToolkit.makeNodeToken(n7);
			n3.addNode(n6);
			n2.addNode(n3);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case COLON:
				;
				break;
			default:
				this.jj_la1[16] = this.jj_gen;
				break label_8;
			}
		}
		n2.nodes.trimToSize();
		this.jj_consume_token(30);
		n8 = JTBToolkit.makeNodeToken(n9);
		n10 = this.MathExpression();
		label_9: while (true) {
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case 32:
				;
				break;
			default:
				this.jj_la1[17] = this.jj_gen;
				break label_9;
			}
			n12 = new NodeSequence(2);
			this.jj_consume_token(32);
			n13 = JTBToolkit.makeNodeToken(n14);
			n12.addNode(n13);
			n15 = this.MathExpression();
			n12.addNode(n15);
			n11.addNode(n12);
		}
		n11.nodes.trimToSize();
		this.jj_consume_token(31);
		n16 = JTBToolkit.makeNodeToken(n17);
		this.jj_consume_token(BPPConstants.DOT);
		n18 = JTBToolkit.makeNodeToken(n19);
		{
			if (true)
				return new JavaStaticMethods(n0, n2, n8, n10, n11, n16, n18);
		}
		throw new Error("Missing return statement in function");
	}

	private boolean jj_2_1(final int xla) {
		this.jj_la = xla;
		this.jj_lastpos = this.jj_scanpos = this.token;
		try {
			return !this.jj_3_1();
		} catch (final LookaheadSuccess ls) {
			return true;
		} finally {
			this.jj_save(0, xla);
		}
	}

	private boolean jj_3_1() {
		if (this.jj_3R_10())
			return true;
		return false;
	}

	private boolean jj_3R_10() {
		if (this.jj_3R_11())
			return true;
		if (this.jj_scan_token(BPPConstants.ASSIGN))
			return true;
		return false;
	}

	private boolean jj_3R_11() {
		if (this.jj_scan_token(BPPConstants.IDENTIFIER))
			return true;
		return false;
	}

	private void jj_add_error_token(final int kind, final int pos) {
		if (pos >= 100)
			return;
		if (pos == this.jj_endpos + 1)
			this.jj_lasttokens[this.jj_endpos++] = kind;
		else if (this.jj_endpos != 0) {
			this.jj_expentry = new int[this.jj_endpos];
			for (int i = 0; i < this.jj_endpos; i++)
				this.jj_expentry[i] = this.jj_lasttokens[i];
			jj_entries_loop: for (final Object name : this.jj_expentries) {
				final int[] oldentry = (int[]) name;
				if (oldentry.length == this.jj_expentry.length) {
					for (int i = 0; i < this.jj_expentry.length; i++)
						if (oldentry[i] != this.jj_expentry[i])
							continue jj_entries_loop;
					this.jj_expentries.add(this.jj_expentry);
					break jj_entries_loop;
				}
			}
			if (pos != 0)
				this.jj_lasttokens[(this.jj_endpos = pos) - 1] = kind;
		}
	}

	private Token jj_consume_token(final int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = this.token).next != null)
			this.token = this.token.next;
		else
			this.token = this.token.next = this.token_source.getNextToken();
		this.jj_ntk = -1;
		if (this.token.kind == kind) {
			this.jj_gen++;
			if (++this.jj_gc > 100) {
				this.jj_gc = 0;
				for (final JJCalls jj_2_rtn : this.jj_2_rtns) {
					JJCalls c = jj_2_rtn;
					while (c != null) {
						if (c.gen < this.jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			return this.token;
		}
		this.token = oldToken;
		this.jj_kind = kind;
		throw this.generateParseException();
	}

	private int jj_ntk() {
		if ((this.jj_nt = this.token.next) == null)
			return this.jj_ntk = (this.token.next = this.token_source.getNextToken()).kind;
		else
			return this.jj_ntk = this.jj_nt.kind;
	}

	private void jj_rescan_token() {
		this.jj_rescan = true;
		for (int i = 0; i < 1; i++)
			try {
				JJCalls p = this.jj_2_rtns[i];
				do {
					if (p.gen > this.jj_gen) {
						this.jj_la = p.arg;
						this.jj_lastpos = this.jj_scanpos = p.first;
						switch (i) {
						case 0:
							this.jj_3_1();
							break;
						}
					}
					p = p.next;
				} while (p != null);
			} catch (final LookaheadSuccess ls) {
			}
		this.jj_rescan = false;
	}

	private void jj_save(final int index, final int xla) {
		JJCalls p = this.jj_2_rtns[index];
		while (p.gen > this.jj_gen) {
			if (p.next == null) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = this.jj_gen + xla - this.jj_la;
		p.first = this.token;
		p.arg = xla;
	}

	private boolean jj_scan_token(final int kind) {
		if (this.jj_scanpos == this.jj_lastpos) {
			this.jj_la--;
			if (this.jj_scanpos.next == null)
				this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next = this.token_source.getNextToken();
			else
				this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next;
		} else
			this.jj_scanpos = this.jj_scanpos.next;
		if (this.jj_rescan) {
			int i = 0;
			Token tok = this.token;
			while (tok != null && tok != this.jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				this.jj_add_error_token(kind, i);
		}
		if (this.jj_scanpos.kind != kind)
			return true;
		if (this.jj_la == 0 && this.jj_scanpos == this.jj_lastpos)
			throw this.jj_ls;
		return false;
	}

	/* Simple Math Operations */
	final public MathExpression MathExpression() throws ParseException {
		// --- JTB generated node declarations ---
		AdditiveExpression n0 = null;
		n0 = this.AdditiveExpression();
		{
			if (true)
				return new MathExpression(n0);
		}
		throw new Error("Missing return statement in function");
	}

	final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
		// --- JTB generated node declarations ---
		UnaryExpression n0 = null;
		final NodeListOptional n1 = new NodeListOptional();
		NodeSequence n2 = null;
		NodeChoice n3 = null;
		NodeToken n4 = null;
		final Token n5 = null;
		NodeToken n6 = null;
		final Token n7 = null;
		NodeToken n8 = null;
		final Token n9 = null;
		UnaryExpression n10 = null;
		n0 = this.UnaryExpression();
		label_5: while (true) {
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case MUL:
			case DIV:
			case MOD:
				;
				break;
			default:
				this.jj_la1[5] = this.jj_gen;
				break label_5;
			}
			n2 = new NodeSequence(2);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case MUL:
				this.jj_consume_token(BPPConstants.MUL);
				n4 = JTBToolkit.makeNodeToken(n5);
				n3 = new NodeChoice(n4, 0, 3);
				break;
			case DIV:
				this.jj_consume_token(BPPConstants.DIV);
				n6 = JTBToolkit.makeNodeToken(n7);
				n3 = new NodeChoice(n6, 1, 3);
				break;
			case MOD:
				this.jj_consume_token(BPPConstants.MOD);
				n8 = JTBToolkit.makeNodeToken(n9);
				n3 = new NodeChoice(n8, 2, 3);
				break;
			default:
				this.jj_la1[6] = this.jj_gen;
				this.jj_consume_token(-1);
				throw new ParseException();
			}
			n2.addNode(n3);
			n10 = this.UnaryExpression();
			n2.addNode(n10);
			n1.addNode(n2);
		}
		n1.nodes.trimToSize();
		{
			if (true)
				return new MultiplicativeExpression(n0, n1);
		}
		throw new Error("Missing return statement in function");
	}

	/** Reinitialise. */
	public void ReInit(final BPPTokenManager tm) {
		this.token_source = tm;
		this.token = new Token();
		this.jj_ntk = -1;
		this.jj_gen = 0;
		for (int i = 0; i < 20; i++)
			this.jj_la1[i] = -1;
		for (int i = 0; i < this.jj_2_rtns.length; i++)
			this.jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(final java.io.InputStream stream) {
		this.ReInit(stream, null);
	}

	/** Reinitialise. */
	public void ReInit(final java.io.InputStream stream, final String encoding) {
		try {
			this.jj_input_stream.ReInit(stream, encoding, 1, 1);
		} catch (final java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		this.token_source.ReInit(this.jj_input_stream);
		this.token = new Token();
		this.jj_ntk = -1;
		this.jj_gen = 0;
		for (int i = 0; i < 20; i++)
			this.jj_la1[i] = -1;
		for (int i = 0; i < this.jj_2_rtns.length; i++)
			this.jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(final java.io.Reader stream) {
		this.jj_input_stream.ReInit(stream, 1, 1);
		this.token_source.ReInit(this.jj_input_stream);
		this.token = new Token();
		this.jj_ntk = -1;
		this.jj_gen = 0;
		for (int i = 0; i < 20; i++)
			this.jj_la1[i] = -1;
		for (int i = 0; i < this.jj_2_rtns.length; i++)
			this.jj_2_rtns[i] = new JJCalls();
	}

	final public RelationalEqualityExpression RelationalEqualityExpression() throws ParseException {
		// --- JTB generated node declarations ---
		RelationalGreaterExpression n0 = null;
		final NodeOptional n1 = new NodeOptional();
		NodeSequence n2 = null;
		NodeChoice n3 = null;
		NodeToken n4 = null;
		final Token n5 = null;
		NodeToken n6 = null;
		final Token n7 = null;
		RelationalGreaterExpression n8 = null;
		n0 = this.RelationalGreaterExpression();
		switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
		case EQ:
		case NE:
			n2 = new NodeSequence(2);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case EQ:
				this.jj_consume_token(BPPConstants.EQ);
				n4 = JTBToolkit.makeNodeToken(n5);
				n3 = new NodeChoice(n4, 0, 2);
				break;
			case NE:
				this.jj_consume_token(BPPConstants.NE);
				n6 = JTBToolkit.makeNodeToken(n7);
				n3 = new NodeChoice(n6, 1, 2);
				break;
			default:
				this.jj_la1[8] = this.jj_gen;
				this.jj_consume_token(-1);
				throw new ParseException();
			}
			n2.addNode(n3);
			n8 = this.RelationalGreaterExpression();
			n2.addNode(n8);
			n1.addNode(n2);
			break;
		default:
			this.jj_la1[9] = this.jj_gen;
			;
		}
		{
			if (true)
				return new RelationalEqualityExpression(n0, n1);
		}
		throw new Error("Missing return statement in function");
	}

	/* Start Simple Relational Test */
	final public RelationalExprssion RelationalExprssion() throws ParseException {
		// --- JTB generated node declarations ---
		RelationalEqualityExpression n0 = null;
		n0 = this.RelationalEqualityExpression();
		{
			if (true)
				return new RelationalExprssion(n0);
		}
		throw new Error("Missing return statement in function");
	}

	final public RelationalGreaterExpression RelationalGreaterExpression() throws ParseException {
		// --- JTB generated node declarations ---
		RelationalLessExpression n0 = null;
		final NodeOptional n1 = new NodeOptional();
		NodeSequence n2 = null;
		NodeChoice n3 = null;
		NodeToken n4 = null;
		final Token n5 = null;
		NodeToken n6 = null;
		final Token n7 = null;
		RelationalLessExpression n8 = null;
		n0 = this.RelationalLessExpression();
		switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
		case GT:
		case GE:
			n2 = new NodeSequence(2);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case GT:
				this.jj_consume_token(BPPConstants.GT);
				n4 = JTBToolkit.makeNodeToken(n5);
				n3 = new NodeChoice(n4, 0, 2);
				break;
			case GE:
				this.jj_consume_token(BPPConstants.GE);
				n6 = JTBToolkit.makeNodeToken(n7);
				n3 = new NodeChoice(n6, 1, 2);
				break;
			default:
				this.jj_la1[10] = this.jj_gen;
				this.jj_consume_token(-1);
				throw new ParseException();
			}
			n2.addNode(n3);
			n8 = this.RelationalLessExpression();
			n2.addNode(n8);
			n1.addNode(n2);
			break;
		default:
			this.jj_la1[11] = this.jj_gen;
			;
		}
		{
			if (true)
				return new RelationalGreaterExpression(n0, n1);
		}
		throw new Error("Missing return statement in function");
	}

	final public RelationalLessExpression RelationalLessExpression() throws ParseException {
		// --- JTB generated node declarations ---
		UnaryRelational n0 = null;
		final NodeOptional n1 = new NodeOptional();
		NodeSequence n2 = null;
		NodeChoice n3 = null;
		NodeToken n4 = null;
		final Token n5 = null;
		NodeToken n6 = null;
		final Token n7 = null;
		UnaryRelational n8 = null;
		n0 = this.UnaryRelational();
		switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
		case LT:
		case LE:
			n2 = new NodeSequence(2);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case LT:
				this.jj_consume_token(BPPConstants.LT);
				n4 = JTBToolkit.makeNodeToken(n5);
				n3 = new NodeChoice(n4, 0, 2);
				break;
			case LE:
				this.jj_consume_token(BPPConstants.LE);
				n6 = JTBToolkit.makeNodeToken(n7);
				n3 = new NodeChoice(n6, 1, 2);
				break;
			default:
				this.jj_la1[12] = this.jj_gen;
				this.jj_consume_token(-1);
				throw new ParseException();
			}
			n2.addNode(n3);
			n8 = this.UnaryRelational();
			n2.addNode(n8);
			n1.addNode(n2);
			break;
		default:
			this.jj_la1[13] = this.jj_gen;
			;
		}
		{
			if (true)
				return new RelationalLessExpression(n0, n1);
		}
		throw new Error("Missing return statement in function");
	}

	/*
	 * Here for packages importation can be one word after “require” or many like :
	 *
	 * require java . require java lang . ...
	 */
	final public Require Require() throws ParseException {
		// --- JTB generated node declarations ---
		NodeToken n0 = null;
		final Token n1 = null;
		final NodeList n2 = new NodeList();
		NodeToken n3 = null;
		final Token n4 = null;
		this.jj_consume_token(BPPConstants.REQUERE);
		n0 = JTBToolkit.makeNodeToken(n1);
		label_3: while (true) {
			this.jj_consume_token(BPPConstants.IDENTIFIER);
			n3 = JTBToolkit.makeNodeToken(n4);
			n2.addNode(n3);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case IDENTIFIER:
				;
				break;
			default:
				this.jj_la1[2] = this.jj_gen;
				break label_3;
			}
		}
		n2.nodes.trimToSize();
		{
			if (true)
				return new Require(n0, n2);
		}
		throw new Error("Missing return statement in function");
	}

	/* GRAMMAR start here */
	/*
	 * This is an enter point for St4tic parsing without it, a parser can't started,
	 * for this rule we need mandatory to specifying a “require” (if you notice “+”,
	 * one or many) and after it a program instructions (notice “*”, no-one or
	 * many):
	 */
	final public Start Start() throws ParseException {
		// --- JTB generated node declarations ---
		final NodeList n0 = new NodeList();
		NodeSequence n1 = null;
		Require n2 = null;
		NodeToken n3 = null;
		final Token n4 = null;
		final NodeListOptional n5 = new NodeListOptional();
		StatementExpression n6 = null;
		label_1: while (true) {
			n1 = new NodeSequence(2);
			n2 = this.Require();
			n1.addNode(n2);
			this.jj_consume_token(BPPConstants.DOT);
			n3 = JTBToolkit.makeNodeToken(n4);
			n1.addNode(n3);
			n0.addNode(n1);
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case REQUERE:
				;
				break;
			default:
				this.jj_la1[0] = this.jj_gen;
				break label_1;
			}
		}
		n0.nodes.trimToSize();
		label_2: while (true) {
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case IF:
			case WHILE:
			case DEF:
			case IDENTIFIER:
				;
				break;
			default:
				this.jj_la1[1] = this.jj_gen;
				break label_2;
			}
			n6 = this.StatementExpression();
			n5.addNode(n6);
		}
		n5.nodes.trimToSize();
		{
			if (true)
				return new Start(n0, n5);
		}
		throw new Error("Missing return statement in function");
	}

	/*
	 * “statement expression” is program body or algorithm can content a many
	 * variables declaration, variables assign, logical tests (if;while) or Java
	 * methods calling (remember in St4tic just public static methods).
	 */
	final public StatementExpression StatementExpression() throws ParseException {
		// --- JTB generated node declarations ---
		NodeChoice n0 = null;
		VariableDeclaration n1 = null;
		VariableAssign n2 = null;
		JavaStaticMethods n3 = null;
		IfExpression n4 = null;
		WhileExpression n5 = null;
		switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
		case DEF:
			n1 = this.VariableDeclaration();
			n0 = new NodeChoice(n1, 0, 5);
			break;
		default:
			this.jj_la1[18] = this.jj_gen;
			if (this.jj_2_1(2)) {
				n2 = this.VariableAssign();
				n0 = new NodeChoice(n2, 1, 5);
			} else
				switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
				case IDENTIFIER:
					n3 = this.JavaStaticMethods();
					n0 = new NodeChoice(n3, 2, 5);
					break;
				case IF:
					n4 = this.IfExpression();
					n0 = new NodeChoice(n4, 3, 5);
					break;
				case WHILE:
					n5 = this.WhileExpression();
					n0 = new NodeChoice(n5, 4, 5);
					break;
				default:
					this.jj_la1[19] = this.jj_gen;
					this.jj_consume_token(-1);
					throw new ParseException();
				}
		}
		{
			if (true)
				return new StatementExpression(n0);
		}
		throw new Error("Missing return statement in function");
	}

	final public UnaryExpression UnaryExpression() throws ParseException {
		// --- JTB generated node declarations ---
		NodeChoice n0 = null;
		NodeSequence n1 = null;
		NodeToken n2 = null;
		final Token n3 = null;
		MathExpression n4 = null;
		NodeToken n5 = null;
		final Token n6 = null;
		NodeToken n7 = null;
		final Token n8 = null;
		VariableName n9 = null;
		switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
		case 30:
			n1 = new NodeSequence(3);
			this.jj_consume_token(30);
			n2 = JTBToolkit.makeNodeToken(n3);
			n1.addNode(n2);
			n4 = this.MathExpression();
			n1.addNode(n4);
			this.jj_consume_token(31);
			n5 = JTBToolkit.makeNodeToken(n6);
			n1.addNode(n5);
			n0 = new NodeChoice(n1, 0, 3);
			break;
		case INTEGER_LITERAL:
			this.jj_consume_token(BPPConstants.INTEGER_LITERAL);
			n7 = JTBToolkit.makeNodeToken(n8);
			n0 = new NodeChoice(n7, 1, 3);
			break;
		case IDENTIFIER:
			n9 = this.VariableName();
			n0 = new NodeChoice(n9, 2, 3);
			break;
		default:
			this.jj_la1[7] = this.jj_gen;
			this.jj_consume_token(-1);
			throw new ParseException();
		}
		{
			if (true)
				return new UnaryExpression(n0);
		}
		throw new Error("Missing return statement in function");
	}

	final public UnaryRelational UnaryRelational() throws ParseException {
		// --- JTB generated node declarations ---
		MathExpression n0 = null;
		n0 = this.MathExpression();
		{
			if (true)
				return new UnaryRelational(n0);
		}
		throw new Error("Missing return statement in function");
	}

	final public VariableAssign VariableAssign() throws ParseException {
		// --- JTB generated node declarations ---
		VariableName n0 = null;
		NodeToken n1 = null;
		final Token n2 = null;
		MathExpression n3 = null;
		NodeToken n4 = null;
		final Token n5 = null;
		n0 = this.VariableName();
		this.jj_consume_token(BPPConstants.ASSIGN);
		n1 = JTBToolkit.makeNodeToken(n2);
		n3 = this.MathExpression();
		this.jj_consume_token(BPPConstants.DOT);
		n4 = JTBToolkit.makeNodeToken(n5);
		{
			if (true)
				return new VariableAssign(n0, n1, n3, n4);
		}
		throw new Error("Missing return statement in function");
	}

	/*
	 * Variable declaration expresion is a syntax of variables declaration in St4tic
	 * in Perl we declare variables by using keyword "my" or VB by using "dim",
	 * St4tic use "def" for definition or define it. like def var = 1.
	 */
	final public VariableDeclaration VariableDeclaration() throws ParseException {
		// --- JTB generated node declarations ---
		NodeToken n0 = null;
		final Token n1 = null;
		VariableName n2 = null;
		NodeToken n3 = null;
		final Token n4 = null;
		MathExpression n5 = null;
		NodeToken n6 = null;
		final Token n7 = null;
		this.jj_consume_token(BPPConstants.DEF);
		n0 = JTBToolkit.makeNodeToken(n1);
		n2 = this.VariableName();
		this.jj_consume_token(BPPConstants.ASSIGN);
		n3 = JTBToolkit.makeNodeToken(n4);
		n5 = this.MathExpression();
		this.jj_consume_token(BPPConstants.DOT);
		n6 = JTBToolkit.makeNodeToken(n7);
		{
			if (true)
				return new VariableDeclaration(n0, n2, n3, n5, n6);
		}
		throw new Error("Missing return statement in function");
	}

	final public VariableName VariableName() throws ParseException {
		// --- JTB generated node declarations ---
		NodeToken n0 = null;
		final Token n1 = null;
		this.jj_consume_token(BPPConstants.IDENTIFIER);
		n0 = JTBToolkit.makeNodeToken(n1);
		{
			if (true)
				return new VariableName(n0);
		}
		throw new Error("Missing return statement in function");
	}

	/*
	 * "while" expression is a classcal test while true repeat something like in :
	 * ----------------------------------------------- Java | VB
	 * ----------------------------------------------- while( 1 > 0 ) | While 1 > 0
	 * { | ... ... | End While } | | Here is : while 1 > 0 do ... stop
	 *
	 * "stop" is end of while block
	 */
	final public WhileExpression WhileExpression() throws ParseException {
		// --- JTB generated node declarations ---
		NodeToken n0 = null;
		final Token n1 = null;
		RelationalExprssion n2 = null;
		NodeToken n3 = null;
		final Token n4 = null;
		final NodeListOptional n5 = new NodeListOptional();
		StatementExpression n6 = null;
		NodeToken n7 = null;
		final Token n8 = null;
		this.jj_consume_token(BPPConstants.WHILE);
		n0 = JTBToolkit.makeNodeToken(n1);
		n2 = this.RelationalExprssion();
		this.jj_consume_token(BPPConstants.DO);
		n3 = JTBToolkit.makeNodeToken(n4);
		label_7: while (true) {
			switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk) {
			case IF:
			case WHILE:
			case DEF:
			case IDENTIFIER:
				;
				break;
			default:
				this.jj_la1[15] = this.jj_gen;
				break label_7;
			}
			n6 = this.StatementExpression();
			n5.addNode(n6);
		}
		n5.nodes.trimToSize();
		this.jj_consume_token(BPPConstants.STOP);
		n7 = JTBToolkit.makeNodeToken(n8);
		{
			if (true)
				return new WhileExpression(n0, n2, n3, n5, n7);
		}
		throw new Error("Missing return statement in function");
	}

}

class JTBToolkit {

	static NodeToken makeNodeToken(final Token t) {
		return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
	}
}
