/* Generated by JTB 1.4.11 */
options
{
JDK_VERSION = "1.5";
  STATIC = false;
}

PARSER_BEGIN(BPP)
package medit.BPP;

import medit.BPP.syntaxtree.*;
import medit.BPP.visitor.*;
import medit.BPP.interpreter.*;
import medit.BPP.syntaxtree.*;


public class BPP {}

class JTBToolkit {

  static NodeToken makeNodeToken(final Token t) {
    return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
  }
}

PARSER_END(BPP)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| < "\"" ( ~["\n", "\r"] )* ( "\n"| "\r"| "\r\n" ) >
}

TOKEN :
{
  < REQUERE : "with" >
| < IF : "if" >
| < WHILE : "while" >
| < DO : "begin" >
| < STOP : "end" >
| < DEF : "var" >
}

TOKEN :
{
  < DOT : "." >
| < COLON : ":" >
| < EQ : "==" >
| < GT : ">" >
| < LT : "<" >
| < GE : ">=" >
| < LE : "<=" >
| < NE : "!=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MUL : "*" >
| < DIV : "/" >
| < MOD : "%" >
| < ASSIGN : "=" >
}

TOKEN :
{
  < INTEGER_LITERAL : ["1"-"9"] ( ["0"-"9"] )*| "0" >
}

TOKEN :
{
  < IDENTIFIER : <LETTER> ( <LETTER>| <DIGIT> )* >
| < #LETTER : ["_", "a"-"z", "A"-"Z"] >
| < #DIGIT : ["0"-"9"] >
}

/* GRAMMAR start here */
/*
	This is an enter point for St4tic parsing without it, a parser can't started,
	for this rule we need mandatory to specifying a “require” (if you notice “+”, one or many)
	and after it a program instructions (notice “*”, no-one or many):
*/
Start Start() :
{
  // --- JTB generated node declarations ---
  NodeList n0 = new NodeList();
  NodeSequence n1 = null;
  Require n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  StatementExpression n6 = null;
}
{
  (
    { n1 = new NodeSequence(2); }
    n2 = Require()
    { n1.addNode(n2); }
    "."
    { n3 = JTBToolkit.makeNodeToken(n4); }
    { n1.addNode(n3); }
    { n0.addNode(n1); }
  )+
  { n0.nodes.trimToSize(); }
  (
    n6 = StatementExpression()
    { n5.addNode(n6); }
  )*
  { n5.nodes.trimToSize(); }
  { return new Start(n0, n5); }
}

/*
	Here for packages importation can be one word after “require” or many like :
	
	require java .
	require java lang .
	...
*/
Require Require() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeList n2 = new NodeList();
  NodeToken n3 = null;
  Token n4 = null;
}
{
  "with"
  { n0 = JTBToolkit.makeNodeToken(n1); }
  (
    < IDENTIFIER >
    { n3 = JTBToolkit.makeNodeToken(n4); }
    { n2.addNode(n3); }
  )+
  { n2.nodes.trimToSize(); }
  { return new Require(n0, n2); }
}

/* Simple Math Operations */
MathExpression MathExpression() :
{
  // --- JTB generated node declarations ---
  AdditiveExpression n0 = null;
}
{
  n0 = AdditiveExpression()
  { return new MathExpression(n0); }
}

AdditiveExpression AdditiveExpression() :
{
  // --- JTB generated node declarations ---
  MultiplicativeExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  MultiplicativeExpression n8 = null;
}
{
  n0 = MultiplicativeExpression()
  (
    { n2 = new NodeSequence(2); }
    (
      (
        "+"
        { n4 = JTBToolkit.makeNodeToken(n5); }
        { n3 = new NodeChoice(n4, 0, 2); }
      |
        "-"
        { n6 = JTBToolkit.makeNodeToken(n7); }
        { n3 = new NodeChoice(n6, 1, 2); }
      )
          )
    { n2.addNode(n3); }
    n8 = MultiplicativeExpression()
    { n2.addNode(n8); }
    { n1.addNode(n2); }
  )*
  { n1.nodes.trimToSize(); }
  { return new AdditiveExpression(n0, n1); }
}

MultiplicativeExpression MultiplicativeExpression() :
{
  // --- JTB generated node declarations ---
  UnaryExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  UnaryExpression n10 = null;
}
{
  n0 = UnaryExpression()
  (
    { n2 = new NodeSequence(2); }
    (
      (
        "*"
        { n4 = JTBToolkit.makeNodeToken(n5); }
        { n3 = new NodeChoice(n4, 0, 3); }
      |
        "/"
        { n6 = JTBToolkit.makeNodeToken(n7); }
        { n3 = new NodeChoice(n6, 1, 3); }
      |
        "%"
        { n8 = JTBToolkit.makeNodeToken(n9); }
        { n3 = new NodeChoice(n8, 2, 3); }
      )
          )
    { n2.addNode(n3); }
    n10 = UnaryExpression()
    { n2.addNode(n10); }
    { n1.addNode(n2); }
  )*
  { n1.nodes.trimToSize(); }
  { return new MultiplicativeExpression(n0, n1); }
}

UnaryExpression UnaryExpression() :
{
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  MathExpression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  VariableName n9 = null;
}
{
  (
    { n1 = new NodeSequence(3); }
    "("
    { n2 = JTBToolkit.makeNodeToken(n3); }
    { n1.addNode(n2); }
    n4 = MathExpression()
    { n1.addNode(n4); }
    ")"
    { n5 = JTBToolkit.makeNodeToken(n6); }
    { n1.addNode(n5); }
    { n0 = new NodeChoice(n1, 0, 3); }
  |
    < INTEGER_LITERAL >
    { n7 = JTBToolkit.makeNodeToken(n8); }
    { n0 = new NodeChoice(n7, 1, 3); }
  |
    n9 = VariableName()
    { n0 = new NodeChoice(n9, 2, 3); }
  )
  { return new UnaryExpression(n0); }
}

/* Start Simple Relational Test */
RelationalExprssion RelationalExprssion() :
{
  // --- JTB generated node declarations ---
  RelationalEqualityExpression n0 = null;
}
{
  n0 = RelationalEqualityExpression()
  { return new RelationalExprssion(n0); }
}

RelationalEqualityExpression RelationalEqualityExpression() :
{
  // --- JTB generated node declarations ---
  RelationalGreaterExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  RelationalGreaterExpression n8 = null;
}
{
  n0 = RelationalGreaterExpression()
  [
    { n2 = new NodeSequence(2); }
    (
      (
        "=="
        { n4 = JTBToolkit.makeNodeToken(n5); }
        { n3 = new NodeChoice(n4, 0, 2); }
      |
        "!="
        { n6 = JTBToolkit.makeNodeToken(n7); }
        { n3 = new NodeChoice(n6, 1, 2); }
      )
          )
    { n2.addNode(n3); }
    n8 = RelationalGreaterExpression()
    { n2.addNode(n8); }
    { n1.addNode(n2); }
  ]
  { return new RelationalEqualityExpression(n0, n1); }
}

RelationalGreaterExpression RelationalGreaterExpression() :
{
  // --- JTB generated node declarations ---
  RelationalLessExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  RelationalLessExpression n8 = null;
}
{
  n0 = RelationalLessExpression()
  [
    { n2 = new NodeSequence(2); }
    (
      (
        ">"
        { n4 = JTBToolkit.makeNodeToken(n5); }
        { n3 = new NodeChoice(n4, 0, 2); }
      |
        ">="
        { n6 = JTBToolkit.makeNodeToken(n7); }
        { n3 = new NodeChoice(n6, 1, 2); }
      )
          )
    { n2.addNode(n3); }
    n8 = RelationalLessExpression()
    { n2.addNode(n8); }
    { n1.addNode(n2); }
  ]
  { return new RelationalGreaterExpression(n0, n1); }
}

RelationalLessExpression RelationalLessExpression() :
{
  // --- JTB generated node declarations ---
  UnaryRelational n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeSequence n2 = null;
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  UnaryRelational n8 = null;
}
{
  n0 = UnaryRelational()
  [
    { n2 = new NodeSequence(2); }
    (
      (
        "<"
        { n4 = JTBToolkit.makeNodeToken(n5); }
        { n3 = new NodeChoice(n4, 0, 2); }
      |
        "<="
        { n6 = JTBToolkit.makeNodeToken(n7); }
        { n3 = new NodeChoice(n6, 1, 2); }
      )
          )
    { n2.addNode(n3); }
    n8 = UnaryRelational()
    { n2.addNode(n8); }
    { n1.addNode(n2); }
  ]
  { return new RelationalLessExpression(n0, n1); }
}

UnaryRelational UnaryRelational() :
{
  // --- JTB generated node declarations ---
  MathExpression n0 = null;
}
{
  n0 = MathExpression()
  { return new UnaryRelational(n0); }
}

/* End Simple Relational Test */
/*
	"if" expression is a classcal test if true do something
	like in :
	-----------------------------------------------
		Java				|	VB
	-----------------------------------------------
	if( 1 > 0 )				|	If 1 > 0 Then	{						|		...		...					|	End If
	}						|
							|	 
	Here is :
	if 1 > 0 do
		...
	stop

	"stop" is end of if block 
*/
IfExpression IfExpression() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  RelationalExprssion n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  StatementExpression n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
}
{
  "if"
  { n0 = JTBToolkit.makeNodeToken(n1); }
  n2 = RelationalExprssion()
  "begin"
  { n3 = JTBToolkit.makeNodeToken(n4); }
  (
    n6 = StatementExpression()
    { n5.addNode(n6); }
  )*
  { n5.nodes.trimToSize(); }
  "end"
  { n7 = JTBToolkit.makeNodeToken(n8); }
  { return new IfExpression(n0, n2, n3, n5, n7); }
}

/*
	"while" expression is a classcal test while true repeat something
	like in :
	-----------------------------------------------
		Java				|	VB
	-----------------------------------------------
	while( 1 > 0 )			|	While 1 > 0
	{						|		...
		...					|	End While
	}						|
							|	 
	Here is :
	while 1 > 0 do
		...
	stop

	"stop" is end of while block 
*/
WhileExpression WhileExpression() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  RelationalExprssion n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  StatementExpression n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
}
{
  "while"
  { n0 = JTBToolkit.makeNodeToken(n1); }
  n2 = RelationalExprssion()
  "begin"
  { n3 = JTBToolkit.makeNodeToken(n4); }
  (
    n6 = StatementExpression()
    { n5.addNode(n6); }
  )*
  { n5.nodes.trimToSize(); }
  "end"
  { n7 = JTBToolkit.makeNodeToken(n8); }
  { return new WhileExpression(n0, n2, n3, n5, n7); }
}

/*
	Variable declaration expresion is a syntax of variables
	declaration in St4tic
	in Perl we declare variables by using keyword "my"
	or VB by using "dim", St4tic use "def" for definition
	or define it.
	like def var = 1. 
*/
VariableDeclaration VariableDeclaration() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  VariableName n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  MathExpression n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
}
{
  "var"
  { n0 = JTBToolkit.makeNodeToken(n1); }
  n2 = VariableName()
  "="
  { n3 = JTBToolkit.makeNodeToken(n4); }
  n5 = MathExpression()
  "."
  { n6 = JTBToolkit.makeNodeToken(n7); }
  { return new VariableDeclaration(n0, n2, n3, n5, n6); }
}

VariableAssign VariableAssign() :
{
  // --- JTB generated node declarations ---
  VariableName n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  MathExpression n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
}
{
  n0 = VariableName()
  "="
  { n1 = JTBToolkit.makeNodeToken(n2); }
  n3 = MathExpression()
  "."
  { n4 = JTBToolkit.makeNodeToken(n5); }
  { return new VariableAssign(n0, n1, n3, n4); }
}

VariableName VariableName() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
}
{
  < IDENTIFIER >
  { n0 = JTBToolkit.makeNodeToken(n1); }
  { return new VariableName(n0); }
}

JavaStaticMethods JavaStaticMethods() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeList n2 = new NodeList();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  MathExpression n10 = null;
  NodeListOptional n11 = new NodeListOptional();
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  MathExpression n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
}
{
  < IDENTIFIER >
  { n0 = JTBToolkit.makeNodeToken(n1); }
  (
    { n3 = new NodeSequence(2); }
    ":"
    { n4 = JTBToolkit.makeNodeToken(n5); }
    { n3.addNode(n4); }
    < IDENTIFIER >
    { n6 = JTBToolkit.makeNodeToken(n7); }
    { n3.addNode(n6); }
    { n2.addNode(n3); }
  )+
  { n2.nodes.trimToSize(); }
  "("
  { n8 = JTBToolkit.makeNodeToken(n9); }
  n10 = MathExpression()
  (
    { n12 = new NodeSequence(2); }
    ","
    { n13 = JTBToolkit.makeNodeToken(n14); }
    { n12.addNode(n13); }
    n15 = MathExpression()
    { n12.addNode(n15); }
    { n11.addNode(n12); }
  )*
  { n11.nodes.trimToSize(); }
  ")"
  { n16 = JTBToolkit.makeNodeToken(n17); }
  "."
  { n18 = JTBToolkit.makeNodeToken(n19); }
  { return new JavaStaticMethods(n0, n2, n8, n10, n11, n16, n18); }
}

/*
	“statement expression” is program body or algorithm can content 
	a many variables declaration, variables assign, logical tests (if;while) 
	or Java methods calling (remember in St4tic just public static methods).
*/
StatementExpression StatementExpression() :
{
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  VariableDeclaration n1 = null;
  VariableAssign n2 = null;
  JavaStaticMethods n3 = null;
  IfExpression n4 = null;
  WhileExpression n5 = null;
}
{
  (
    n1 = VariableDeclaration()
    { n0 = new NodeChoice(n1, 0, 5); }
  |
    LOOKAHEAD( 2 )
    n2 = VariableAssign()
    { n0 = new NodeChoice(n2, 1, 5); }
  |
    n3 = JavaStaticMethods()
    { n0 = new NodeChoice(n3, 2, 5); }
  |
    n4 = IfExpression()
    { n0 = new NodeChoice(n4, 3, 5); }
  |
    n5 = WhileExpression()
    { n0 = new NodeChoice(n5, 4, 5); }
  )
  { return new StatementExpression(n0); }
}
